{"version":3,"sources":["transport/usb.ts"],"names":[],"mappings":"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","file":"usb.js","sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Device, InEndpoint, OutEndpoint} from \"usb\";\nimport { Transport } from \"./\";\n\n/**\n * @hidden\n */\nconst LIBUSB_REQUEST_TYPE_CLASS = (0x01 << 5);\n/**\n * @hidden\n */\nconst LIBUSB_RECIPIENT_INTERFACE = 0x01;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_OUT = 0x00;\n/**\n * @hidden\n */\nconst LIBUSB_ENDPOINT_IN = 0x80;\n/**\n * @hidden\n */\nconst DEFAULT_CONFIGURATION = 1;\n/**\n * @hidden\n */\nconst DEFAULT_CLASS = 0xFF;\n\n/**\n * @hidden\n */\nconst GET_REPORT = 0x01;\n/**\n * @hidden\n */\nconst SET_REPORT = 0x09;\n/**\n * @hidden\n */\nconst OUT_REPORT = 0x200;\n/**\n * @hidden\n */\nconst IN_REPORT = 0x100;\n\n/**\n * USB Transport class\n */\nexport class USB implements Transport {\n\n    private interfaceNumber?: number;\n    private endpointIn?: InEndpoint;\n    private endpointOut?: OutEndpoint;\n    public readonly packetSize = 64;\n\n    /**\n     * USB constructor\n     * @param device USB device to use\n     * @param interfaceClass Optional interface class to use (default: 0xFF)\n     * @param configuration Optional Configuration to use (default: 1)\n     * @param alwaysControlTransfer Whether to always use control transfer instead of endpoints (default: false)\n     */\n    constructor(private device: Device, private interfaceClass = DEFAULT_CLASS, private configuration = DEFAULT_CONFIGURATION, private alwaysControlTransfer: boolean = false) {\n    }\n\n    private bufferToDataView(buffer: Buffer): DataView {\n        const arrayBuffer = new Uint8Array(buffer).buffer;\n        return new DataView(arrayBuffer);\n    }\n\n    private bufferSourceToBuffer(bufferSource: ArrayBuffer | ArrayBufferView): Buffer {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(bufferSource) ? bufferSource.buffer : bufferSource;\n        return Buffer.from(arrayBuffer);\n    }\n\n    private extendBuffer(data: BufferSource, packetSize: number): BufferSource {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(data) ? data.buffer : data;\n        const length = Math.min(arrayBuffer.byteLength, packetSize);\n\n        const result = new Uint8Array(length);\n        result.set(new Uint8Array(arrayBuffer));\n\n        return result;\n    }\n\n    /**\n     * Open device\n     * @returns Promise\n     */\n    public open(): Promise<void> {\n        return new Promise((resolve, reject) => {\n            this.device.open();\n            this.device.setConfiguration(this.configuration, error => {\n                if (error) return reject(error);\n                const interfaces = this.device.interfaces.filter(iface => {\n                    return iface.descriptor.bInterfaceClass === this.interfaceClass;\n                });\n\n                if (!interfaces.length) {\n                    throw new Error(\"No valid interfaces found.\");\n                }\n\n                // Prefer interface with endpoints\n                let selectedInterface = interfaces.find(iface => iface.endpoints.length > 0);\n\n                // Otherwise use the first\n                if (!selectedInterface) {\n                    selectedInterface = interfaces[0];\n                }\n\n                this.interfaceNumber = selectedInterface.interfaceNumber;\n\n                // If we always want to use control transfer, don't find/set endpoints and claim interface\n                if (!this.alwaysControlTransfer) {\n                    const endpoints = selectedInterface.endpoints;\n\n                    this.endpointIn = undefined;\n                    this.endpointOut = undefined;\n\n                    for (const endpoint of endpoints) {\n                        if (endpoint.direction === \"in\") this.endpointIn = (endpoint as InEndpoint);\n                        else this.endpointOut = (endpoint as OutEndpoint);\n                    }\n\n                    // If endpoints are found, claim the interface\n                    if (this.endpointIn || this.endpointOut) {\n\n                        // If the interface can't be claimed, use control transfer\n                        try {\n                            selectedInterface.claim();\n                        } catch (_e) {\n                            this.endpointIn = undefined;\n                            this.endpointOut = undefined;\n                        }\n                    }\n                }\n\n                resolve();\n            });\n        });\n    }\n\n    /**\n     * Close device\n     * @returns Promise\n     */\n    public close(): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            this.device.close();\n            resolve();\n        });\n    }\n\n    /**\n     * Read from device\n     * @returns Promise of DataView\n     */\n    public read(): Promise<DataView> {\n        return new Promise((resolve, reject) => {\n            if (this.interfaceNumber === undefined) return reject(\"No device opened\");\n\n            // Use endpoint if it exists\n            if (this.endpointIn) {\n                this.endpointIn.transfer(this.packetSize, (error, buffer) => {\n                    if (error) return reject(error);\n                    resolve(this.bufferToDataView(buffer));\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_IN | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                GET_REPORT,\n                IN_REPORT,\n                this.interfaceNumber,\n                this.packetSize,\n                (error, buffer) => {\n                    if (error) return reject(error);\n                    if (!buffer) return reject(\"No buffer read\");\n                    resolve(this.bufferToDataView(buffer));\n                }\n            );\n        });\n    }\n\n    /**\n     * Write to device\n     * @param data Data to write\n     * @returns Promise\n     */\n    public write(data: BufferSource): Promise<void> {\n        const extended = this.extendBuffer(data, this.packetSize);\n        const buffer = this.bufferSourceToBuffer(extended);\n\n        return new Promise((resolve, reject) => {\n            if (this.interfaceNumber === undefined) return reject(\"No device opened\");\n\n            // Use endpoint if it exists\n            if (this.endpointOut) {\n                this.endpointOut.transfer(buffer, error => {\n                    if (error) return reject(error);\n                    resolve();\n                });\n                return;\n            }\n\n            // Fallback to using control transfer\n            this.device.controlTransfer(\n                LIBUSB_ENDPOINT_OUT | LIBUSB_REQUEST_TYPE_CLASS | LIBUSB_RECIPIENT_INTERFACE,\n                SET_REPORT,\n                OUT_REPORT,\n                this.interfaceNumber,\n                buffer,\n                error => {\n                    if (error) return reject(error);\n                    resolve();\n                }\n            );\n        });\n    }\n}\n"],"sourceRoot":"../../src"}