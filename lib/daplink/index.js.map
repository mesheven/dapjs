{"version":3,"sources":["daplink/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { TextDecoder } from \"./text-decoder\";\nimport { CmsisDAP, DAPProtocol, DEFAULT_CLOCK_FREQUENCY } from \"../proxy\";\nimport { Transport } from \"../transport\";\nimport { DAPLinkFlash, DAPLinkSerial } from \"./enums\";\n\n/**\n * @hidden\n */\nconst DEFAULT_BAUDRATE = 9600;\n/**\n * @hidden\n */\nconst DEFAULT_SERIAL_DELAY = 100;\n/**\n * @hidden\n */\nconst DEFAULT_PAGE_SIZE = 62;\n\n/**\n * @hidden\n */\nconst decoder = new TextDecoder();\n\n/**\n * DAPLink Class\n */\nexport class DAPLink extends CmsisDAP {\n\n    /**\n     * Progress event\n     * @event\n     */\n    public static EVENT_PROGRESS: string = \"progress\";\n\n    /**\n     * Serial read event\n     * @event\n     */\n    public static EVENT_SERIAL_DATA: string = \"serial\";\n\n    /**\n     * @hidden\n     */\n    protected serialPolling = false;\n\n    /**\n     * @hidden\n     */\n    protected serialListeners = false;\n\n    /**\n     * DAPLink constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        super(transport, mode, clockFrequency);\n\n        this.on(\"newListener\", async event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = true;\n                }\n            }\n        });\n\n        this.on(\"removeListener\", event => {\n            if (event === DAPLink.EVENT_SERIAL_DATA) {\n                const listenerCount = this.listenerCount(event);\n\n                if (listenerCount === 0) {\n                    this.serialListeners = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * Detect if buffer contains text or binary data\n     */\n    private isBufferBinary(buffer: ArrayBuffer): boolean {\n        const numberArray = Array.prototype.slice.call(new Uint16Array(buffer, 0, 50));\n        const bufferString: string = String.fromCharCode.apply(null, numberArray);\n\n        for (let i = 0; i < bufferString.length; i++) {\n            const charCode = bufferString.charCodeAt(i);\n            // 65533 is a code for unknown character\n            // 0-8 are codes for control characters\n            if (charCode === 65533 || charCode <= 8) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private writeBuffer(buffer: ArrayBuffer, pageSize: number, offset: number = 0): Promise<void> {\n        const end = Math.min(buffer.byteLength, offset + pageSize);\n        const page = buffer.slice(offset, end);\n        const data = new Uint8Array(page.byteLength + 1);\n\n        data.set([page.byteLength]);\n        data.set(new Uint8Array(page), 1);\n\n        return this.send(DAPLinkFlash.WRITE, data)\n        .then(() => {\n            this.emit(DAPLink.EVENT_PROGRESS, offset / buffer.byteLength);\n            if (end < buffer.byteLength) {\n                return this.writeBuffer(buffer, pageSize, end);\n            }\n            return Promise.resolve();\n        });\n    }\n\n    /**\n     * Flash the target\n     * @param buffer The image to flash\n     * @param pageSize The page size to use (defaults to 62)\n     * @returns Promise\n     */\n    public flash(buffer: BufferSource, pageSize: number = DEFAULT_PAGE_SIZE): Promise<void> {\n        function isView(source: ArrayBuffer | ArrayBufferView): source is ArrayBufferView {\n            return (source as ArrayBufferView).buffer !== undefined;\n        }\n\n        const arrayBuffer = isView(buffer) ? buffer.buffer : buffer;\n        const streamType = this.isBufferBinary(arrayBuffer) ? 0 : 1;\n\n        return this.send(DAPLinkFlash.OPEN, new Uint32Array([streamType]))\n        .then(result => {\n            // An error occurred\n            if (result.getUint8(1) !== 0) return Promise.reject(\"Flash error\");\n            return this.writeBuffer(arrayBuffer, pageSize);\n        })\n        .then(() => {\n            this.emit(DAPLink.EVENT_PROGRESS, 1.0);\n            return this.send(DAPLinkFlash.CLOSE);\n        })\n        .then(result => {\n            // An error occurred\n            if (result.getUint8(1) !== 0) return Promise.reject(\"Flash error\");\n            return this.send(DAPLinkFlash.RESET);\n        })\n        .then(() => undefined);\n    }\n\n    /**\n     * Get the serial baud rate setting\n     * @returns Promise of baud rate\n     */\n    public getSerialBaudrate(): Promise<number> {\n        return this.send(DAPLinkSerial.READ_SETTINGS)\n        .then(result => {\n            return result.getUint32(1, true);\n        });\n    }\n\n    /**\n     * Set the serial baud rate setting\n     * @param baudrate The baudrate to use (defaults to 9600)\n     * @returns Promise\n     */\n    public setSerialBaudrate(baudrate: number = DEFAULT_BAUDRATE): Promise<void> {\n        return this.send(DAPLinkSerial.WRITE_SETTINGS, new Uint32Array([baudrate]))\n        .then(() => undefined);\n    }\n\n    /**\n     * Write serial data\n     * @param data The data to write\n     * @returns Promise\n     */\n    public serialWrite(data: string): Promise<void> {\n        const arrayData = data.split(\"\").map((e: string) => e.charCodeAt(0));\n        arrayData.unshift(arrayData.length);\n        return this.send(DAPLinkSerial.WRITE, new Uint8Array(arrayData).buffer)\n        .then(() => undefined);\n    }\n\n    /**\n     * Read serial data\n     * @returns Promise of any arrayBuffer read\n     */\n    public serialRead(): Promise<ArrayBuffer | undefined> {\n        return this.send(DAPLinkSerial.READ)\n        .then(serialData => {\n            // Check if there is any data returned from the device\n            if (serialData.byteLength === 0) {\n                return undefined;\n            }\n\n            // First byte contains the vendor code\n            if (serialData.getUint8(0) !== DAPLinkSerial.READ) {\n                return undefined;\n            }\n\n            // Second byte contains the actual length of data read from the device\n            const dataLength = serialData.getUint8(1);\n            if (dataLength === 0) {\n                return undefined;\n            }\n\n            const offset = 2;\n            return serialData.buffer.slice(offset, offset + dataLength);\n        });\n    }\n\n    /**\n     * Start listening for serial data\n     * @param serialDelay The serial delay to use (default 100)\n     * @param autoConnect whether to automatically connect to the target (default true)\n     */\n    public async startSerialRead(serialDelay: number = DEFAULT_SERIAL_DELAY, autoConnect = true) {\n        this.serialPolling = true;\n\n        while (this.serialPolling) {\n\n            // Don't read serial output unless we have event listeners\n            if (this.serialListeners) {\n\n                // Remember connection state\n                const connectedState = this.connected;\n\n                if (this.connected === false && autoConnect === true) {\n                    await this.connect();\n                }\n\n                const serialData = await this.serialRead();\n\n                // Put state back\n                if (connectedState === false && autoConnect === true) {\n                    await this.disconnect();\n                }\n\n                if (serialData !== undefined) {\n                    const data = decoder.decode(serialData);\n                    this.emit(DAPLink.EVENT_SERIAL_DATA, data);\n                }\n            }\n\n            await new Promise(resolve => setTimeout(() => resolve(), serialDelay));\n        }\n    }\n\n    /**\n     * Stop listening for serial data\n     */\n    public stopSerialRead() {\n        this.serialPolling = false;\n    }\n}\n\nexport * from \"./enums\";\n"],"sourceRoot":"../../src"}